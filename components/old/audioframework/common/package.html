<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
</head>
<body>
Interface, classes and ECT-compatible beans for assembling audio
capture and simple audio analysis applications. Based structurally on
visionframework, {@link ect.components.visionframe}.<br>
<h2>Audio Framework</h2>
<p>Framework classes:</p>
<ul>
  <li>JMF Audio Capture device manager/factory, {@link
equip.ect.components.audioframework.capture.AudioCaptureManager}
(instantiated by ECT).</li>
  <li>{@link
ect.components.audioframework.capture.AudioCaptureDevice},
instantiated dynamically by {@link
ect.components.audioframework.capture.AudioCaptureManager}, and
supporting {@link PushFrameSource} interface for audio streaming to
other components. Normal formats are float per sample and short per
sample (which is typically what comes out of JMF), 1 channel (but
should be configurable for stereo in the future). <br>
  </li>
  <li>{@link PushFrameSource} interface for audio stream producers,
which allows (un)registration of consumer's {@link FrameHandler}, which
is called for each {@link Frame}.</li>
  <li>{@link Frame}, a single audio frame, with various audio
processing utility methods.</li>
  <li>{@link AbstractAudioProcessor}, base class for audio components
which has embedded HTTP server for configuration and image peeking, and
supports various internal processors. </li>
</ul>
<p>The initial processor class - take an image (and optionally a
reference image), process it, and output another image are mostly
embedded in {@link AbstractAudioProcessor} and accessible through its
configuration. These are::</p>
<ul>
  <li>{@link AbstractAudioProcessor.AbsProcessor}, emits frames with
each sample absolute (i.e. negative values made positive).
Configuration syntax "Abs()".</li>
  <li>{@link AbstractAudioProcessor.SquareProcessor}, emits frames with
each
sample the square of the input - good for determining noise/energy
level in the sound (with {@link
equip.ect.components.audioframework.average.AudioAverage}.
Configuration
syntax "Square()".</li>
  <li>{@link AbstractAudioProcessor.SubsampleProcessor}, emits frames
with each
sample the average of N input samples. Note: this simple averaging will
result in aliasing artefacts in the final sound; a better subsampling
with low-pass filtering should be implemented and used in sonically
demanding applications. Configuration
syntax "Subsample(N)", e.g. "Subsample(4)".</li>
  <li>{@link AbstractAudioProcessor.WindowProcessor}, emits frames with
a hamming-style window
(alpha+(1-alpha)*(1+cos(2*pi*isample/framesize))/2) applied to the
frame. The true hamming window has alpha=0.02. This should be done
before any operation which convert to frequency domain (e.g.
"FrequencyMatch") to reduce the effects of the sound being effectively
truncated at the beginning and end of the frame. Configuration
syntax "Window(ALPHA,MAXLENSECONDS)", e.g. "Window(0.02,1)".</li>
  <li>{@link AbstractAudioProcessor.GainProcessor}, emits frames with
each
sample scaled by the specified amount (and clipped in short
representation if off-scale). Configuration
syntax "Gain(GAIN)", e.g. "Gain(10)".</li>
  <li>{@link AbstractAudioProcessor.FrequencyMatchProcessor}, emits
frames with each
sample being the amount of energy in the input frame at the specified
frequency. The frequency 0 is used to request total frame energy.
Energies are scaled to be per-sample. Configuration
syntax "FrequencyMatch(F0, F1, F2, ...)", e.g. "FrequencyMatch(0, 100,
200)" will output three 'samples', the total evergy per sample
(average), the energy at 100Hz and the energy at 200Hz. The selectivity
of this process will depend on the number of cycles per frame.</li>
  <ul>
    <li>A few notes... normal concert A is 440Hz. There are 12
semitones per octave (A A# B B C C# D# E F F# G G#) in the european
scale. One octave is a factor of 2 frequency. Semitones (are
approximately) equal ratio steps, i.e. 12th root of 2, =
1.0594630943592952645618252949463, or 5.9463% change in frequency.
Frequency ratios in the full scale are:</li>
  </ul>
  <ul>
    <ul>
      <li>A 1</li>
      <li>A# 1.0594630943592952645618252949463</li>
      <li>B 1.1224620483093729814335330496792</li>
      <li>C 1.1892071150027210667174999705605</li>
      <li>C# 1.2599210498948731647672106072782</li>
      <li>D 1.3348398541700343648308318811845<br>
      </li>
      <li>D# 1.4142135623730950488016887242097<br>
      </li>
      <li>E 1.4983070768766814987992807320298<br>
      </li>
      <li>F 1.5874010519681994747517056392723<br>
      </li>
      <li>F# 1.6817928305074290860622509524664<br>
      </li>
      <li>G 1.781797436280678609480452411181<br>
      </li>
      <li>G# 1.8877486253633869932838263133351</li>
      <li>A' 2</li>
    </ul>
    <li>Frequencies for A below concert A to concert A are:</li>
    <ul>
      <li>A 220Hz</li>
    </ul>
    <ul>
      <li>A# 233.08188075904495820360156488812</li>
    </ul>
    <ul>
      <li>B 246.94165062806205591537727092938</li>
    </ul>
    <ul>
      <li>C 261.6255653005986346778499935232</li>
    </ul>
    <ul>
      <li>C# 277.18263097687209624878633360116</li>
    </ul>
    <ul>
      <li>D 293.66476791740756026278301386048<br>
      </li>
    </ul>
    <ul>
      <li>D# 311.12698372208091073637151932598<br>
      </li>
    </ul>
    <ul>
      <li>E 329.62755691286992973584176104638<br>
      </li>
    </ul>
    <ul>
      <li>F 349.22823143300388444537524063984<br>
      </li>
    </ul>
    <ul>
      <li>F# 369.99442271163439893369520954252<br>
      </li>
    </ul>
    <ul>
      <li>G 391.99543598174929408569953045982<br>
      </li>
    </ul>
    <ul>
      <li>G# 415.3046975799451385224417889337</li>
    </ul>
    <ul>
      <li>A' 440Hz</li>
      <li>A# 466.1637615180899164072031297762</li>
      <li>B 493.8833012561241118307545418586</li>
      <li>C 523.2511306011972693556999870464</li>
      <li>C# 554.3652619537441924975726672022</li>
      <li>D 587.3295358348151205255660277208<br>
      </li>
      <li>D# 622.2539674441618214727430386518<br>
      </li>
      <li>E 659.2551138257398594716835220926<br>
      </li>
      <li>F 698.4564628660077688907504812796<br>
      </li>
      <li>F# 739.988845423268797867390419085<br>
      </li>
      <li>G 783.9908719634985881713990609196<br>
      </li>
      <li>G# 830.6093951598902770448835778674</li>
      <li>A'' 880Hz</li>
      <li>e.g.
Format(float),Window(0.02),FrequencyMatch(0,587.3). <br>
      </li>
    </ul>
    <li>Consider using this with an {@link
ect.components.audioframework.selectvalue.AudioSelectValue}
analyser.<br>
    </li>
  </ul>
  <li>{@link AbstractAudioProcessor.FormatProcessor}, emits frames in
the requested format. Configuration
syntax "Format(float | short)", e.g. "Format(float)".<br>
  </li>
</ul>
<p>Initial analyser classes - take an image, process it, and output
summary metrics:</p>
<ul>
  <li>{@link equip.ect.components.audioframework.average.AudioAverage},
emits the average sample value for the frame. Also configurable via
Browser, syntax "Average(threshold)", e.g. "Average(0.01)".</li>
  <li>{@link
ect.components.audioframework.selectvalue.AudioSelectValue} emits
the ratio of a specified sample value divided by the first (zeroth)
sample value in the input frame. This only really makes sense after a
frequency match processor, with the first frequency as 0 (total
energy). Also configurable via
Browser, syntax "SelectValue(INDEX,THRESHOLD)", e.g.
"SelectValue(1,0.001)". E.g. D above concert A,
"Format(float),Window(0.02,0.03),FrequencyMatch(0,587.3),SelectValue(1,0.1)",
E "Format(float),Window(0.02,0.03),FrequencyMatch(0,659.2),SelectValue(1,0.1)",
F# "Format(float),Window(0.02,0.03),FrequencyMatch(0,739.9),SelectValue(1,0.1)".<br>
  </li>
</ul>
<h2>Examples</h2>
<h3>Noise level monitor</h3>
<ul>
  <li>Request a AudioDeviceManager; AudioCaptureDevice components
appears to represent available capture device(s). I think you can use
either the dsound or the javasound one (I have tried javasound so far).<br>
  </li>
  <li>Request an AudioAverage component; connect the processor's
"source" to the average's "sink". Configure it (using a web browser or
by setting the configuration property) with a reformat to float,
square, and average with guessed initial threshold e.g.
"Format(float),Square(),Average(0.01)". <br>
  </li>
  <li>Voila...the "average" is a measure of noise level (averaged per
sample over each frame). Hopefully. Adjust the configured threshold to
what you want for triggering.<br>
  </li>
</ul>
</body>
</html>
