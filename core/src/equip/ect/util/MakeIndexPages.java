package equip.ect.util;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

/**
 * Make HTML directory index page(s), similar to those generated by a normal server.
 */
public class MakeIndexPages
{
	static final int DATE_LEN = 20;
	static final int LENGTH_LEN = 10;

	public static void main(final String[] args)
	{
		int ai = 0;
		do
		{
			final File dir = new File(args.length > ai ? args[ai] : ".");
			makeIndex(dir, true);
			ai++;
		}
		while (ai < args.length);
	}

	static void makeIndex(final File dir, final boolean recurse)
	{
		try
		{

			System.out.println("In directory: " + dir + "...");
			final File index = new File(dir, "index.html");
			if (index.exists())
			{
				System.out.println("Index file " + index + " already exists");
				return;
			}
			final FileOutputStream fout = new FileOutputStream(index);
			final PrintWriter pout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(fout)));
			pout.println("<html><head><title>Directory Listing " + dir + "</title></head><body>\n");
			pout.println("<h1>Directory Listing " + dir + "</h1>\n");
			pout.println("<p>Generated " + printDate(System.currentTimeMillis()) + "</p>");
			final File parent = new File(dir, "..");
			final File[] files1 = dir.listFiles();
			final File[] files = new File[files1.length + 1];
			System.arraycopy(files1, 0, files, 1, files1.length);
			files[0] = parent;
			int maxlen = 4;
			for (final File file : files)
			{
				if (file.equals(index))
				{
					continue;
				}
				if (file.getName().length() > maxlen)
				{
					maxlen = file.getName().length();
				}
			}
			maxlen++;
			pout.println("<pre>" + padr("Name", maxlen) + " " + padr("Last modified", DATE_LEN) + " "
					+ padl("Size", LENGTH_LEN));
			for (int fi = 0; fi < files.length; fi++)
			{
				if (files[fi].equals(index))
				{
					continue;
				}
				pout.print("<a href=\"" + files[fi].getName() + (files[fi].isDirectory() ? "/" : "") + "\">"
						+ padr(files[fi].getName() + (files[fi].isDirectory() ? "/" : "") + "</a>", maxlen + 4) + " ");
				final long modified = files[fi].lastModified();
				pout.print(padr(printDate(modified), DATE_LEN) + " ");
				if (files[fi].isFile() && !files[fi].isDirectory() && !files[fi].getName().equals(".."))
				{
					pout.print(padl(new Long(files[fi].length()).toString(), LENGTH_LEN));
				}
				else
				{
					pout.print(padl("-", LENGTH_LEN));
				}
				pout.println("");
			}
			pout.println("</pre>");
			pout.println("</body></html>\n");
			pout.flush();
			pout.close();

			if (recurse)
			{
				for (int fi = 0; fi < files.length; fi++)
				{
					if (files[fi].equals(index) || files[fi].equals(parent) || !files[fi].isDirectory())
					{
						continue;
					}
					makeIndex(files[fi], recurse);
				}
			}
		}
		catch (final Exception e)
		{
			System.err.println("ERROR in dir " + dir + ": " + e);
			e.printStackTrace(System.err);
		}
		return;
	}

	protected static String escape(final String s)
	{
		/*
		 * StringBuffer b = new StringBuffer(); for (int i=0; i<s.length(); i++) switch
		 * (s.charAt(i)) { case '<': b.append("&lt;"); break; case '&': b.append("&amp;"); break;
		 * default: b.append(s.charAt(i)); } return b.toString();
		 */
		return s;
	}

	protected static String padl(final String in, final int len)
	{
		final StringBuffer b = new StringBuffer();
		for (int i = in.length(); i < len; i++)
		{
			b.append(' ');
		}
		b.append(escape(in));
		return b.toString();
	}

	protected static String padr(final String in, final int len)
	{
		final StringBuffer b = new StringBuffer(escape(in));
		for (int i = in.length(); i < len; i++)
		{
			b.append(' ');
		}
		return b.toString();
	}

	protected static String printDate(final long date)
	{
		// e.g.Sun, 06 Nov 1994 08:49:37 GMT
		final java.text.SimpleDateFormat df = new java.text.SimpleDateFormat("dd-MMM-yyyy HH:mm:ss");
		return df.format(new java.util.Date(date));
	}
}
