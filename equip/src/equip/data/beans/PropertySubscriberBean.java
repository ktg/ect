/*
<COPYRIGHT>

Copyright (c) 2002-2005, University of Nottingham
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 - Neither the name of the University of Nottingham
   nor the names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</COPYRIGHT>

Created by: Chris Greenhalgh (University of Nottingham)
Contributors:
  Chris Greenhalgh (University of Nottingham)

*/
/* Chris Greenhalgh
 * 25 Sept 2002
 * $Id: PropertySubscriberBean.java,v 1.1.1.1 2005/03/08 16:17:22 cgreenhalgh Exp $
 */
package equip.data.beans;

import java.beans.*;
import java.beans.beancontext.*;

import java.lang.reflect.*;

import equip.runtime.*;
import equip.data.*;

import java.util.Vector;
import java.util.Hashtable;

/** take a tuple from a dataspace and present as a bean property.
 *
 * monitors data item(s) of the form generated by 
 * PropertyPublisherBean and maps to a regular bean property
 * and optionally sets anther beans property to match.
 *
 * This bean monitor assumes that there will only be at most one
 * data item with the given class and item name. If more exist then
 * the most recently added will be used.
 *
 * PropertyPublisherBean publishes a data item of class
 * equip.data.Tuple with two fields. The first is a
 * equip.data.StringBox with the nominal class name of the tuple,
 * and the second is the property value itself (if a subclass of 
 * equip.runtime.ValueBase) or an equip.data.SerializedObject (if the
 * property value is serializable). The name of the item (field of
 * equip.data.ItemData) is also set by configuration to identify 
 * individual data items. The GUID is arbitrary and allocated on 
 * creation.
 * 
 * To be active we need:
 * - a dataspace (reference to equip.data.beans.DataspaceBean)
 * - a tuple nominal class name (String)
 * - a data item name (String)
 *
 * For the optional property push mode, i.e. setting another bean's
 * property we also need:
 * - a reference to the bean (java.lang.Object)
 * - the name of the property to be set on that bean.
 * 
 * In any case, the value is made available as the bean property 'value',
 * of type java.lang.Object which supports PropertyChangeListeners.
 */
public class PropertySubscriberBean extends BeanContextChildSupport 
    implements DataspaceEventListener {

    /** no-arg constructor - required */
    public PropertySubscriberBean() {
    }
    
    /** debug */
    public boolean debug = false;
    public void setDebug(boolean d) { debug = d; }
    public boolean getDebug() { return debug; }

    /** last value */
    protected java.lang.Object mValue = null;
    
    /** push target as object */
    protected java.lang.Object mPushTarget = null;

    /** push target property name */
    protected String mPushPropertyName = null;

    /** push target property type/class */
    protected Class mPushPropertyClass = null;

    /** dataspace */
    protected DataspaceBean mDataspace = null;
    
    /** item name */
    protected String mItemName = null;

    /** item class name */
    protected String mItemClassName = null;

    /** active/connected */
    protected boolean mIsConnected = false;

    /** push active */
    protected boolean mPushActive = false;

    /** dataspace current item id */
    protected GUID mCurrentItemId = null;

    /** dataspace time-order list of matching item ids */
    protected Vector mItemIds = new Vector();

    /** dataspace callback session */
    protected DataSession dsSession = null;

    /** fire property changed */
    public void firePropertyChange(String propertyName,
				    java.lang.Object oldValue,
				    java.lang.Object newValue) {
	try {
	    pcSupport.firePropertyChange(propertyName, oldValue, newValue);
	} catch (Exception e) {
	    System.err.println("ERROR: PropertySubscriberBean "+
			       "firePropertyChange ("+propertyName+
			       "): "+e);
	    e.printStackTrace(System.err);
	}
    }

    /** push target setter - initialisation time only */
    public void setPushTarget(java.lang.Object pushTarget) {
	java.lang.Object oldValue = mPushTarget;
	synchronized (this) {
	    disconnectPushTarget();
	    mPushTarget = pushTarget;
	    connectPushTarget();
	}
	firePropertyChange("pushTarget", oldValue, pushTarget);
    }
    /** source getter */
    public java.lang.Object getPushTarget() {
	return mPushTarget;
    }

    /** property name setter - initialisation time only */
    public void setPushPropertyName(String pushPropertyName) {
	String oldValue = mPushPropertyName;
	synchronized (this) {
	    disconnectPushTarget();
	    mPushPropertyName = pushPropertyName;
	    connectPushTarget();
	}
	firePropertyChange("pushPropertyName", oldValue, pushPropertyName);
    }
    /** property name getter */
    public String getPushPropertyName() {
	return mPushPropertyName;
    }

    /** item name setter - initialisation time only */
    public void setItemName(String itemName) {
	String oldValue = mItemName;
	synchronized (this) {
	    disconnectSource();
	    mItemName = itemName;
	    connectSource();
	}
	firePropertyChange("itemName", oldValue, itemName);
    }
    /** item name getter */
    public String getItemName() {
	return mItemName;
    }

    /** item class name setter - initialisation time only */
    public void setItemClassName(String itemClassName) {
	String oldValue = mItemClassName;
	synchronized (this) {
	    disconnectSource();
	    mItemClassName = itemClassName;
	    connectSource();
	}
	firePropertyChange("itemClassName", oldValue, itemClassName);
    }
    /** item name getter */
    public String getItemClassName() {
	return mItemClassName;
    }

    /** dataspace setter - initialisation time only */
    public void setDataspace(DataspaceBean dataspace) {
	DataspaceBean oldValue = mDataspace;
	synchronized (this) {
	    disconnectSource();
	    mDataspace = dataspace;
	    connectSource();
	}
	firePropertyChange("dataspace", oldValue, dataspace);
    }
    /** source getter */
    public DataspaceBean getDataspace() {
	return mDataspace;
    }

    /** property detter Method */
    private Method mSetPropertyMethod = null;

    /** undo plumbing to set source */
    private synchronized void disconnectSource() {
	disconnectPushTarget();
	if (!mIsConnected)
	    return;
	// deregister from DS
	if (dsSession!=null && mDataspace!=null) {
	    try {
		if (debug)
		    System.err.println("PropertySubscriberBean remove "+
				       "listener...");
		mDataspace.removeDataspaceEventListener(dsSession);
	    } catch (Exception e) {
		System.err.println("ERROR: PropertySubscriberBean remove "+
				   "DS listener: "+e);
		e.printStackTrace(System.err);
	    }
	}
	mCurrentItemId = null;
	mItemIds.removeAllElements();
	mValue = null;
	dsSession = null;
	mIsConnected = false;
    }
    /** undo plumbing for push target */
    private synchronized void disconnectPushTarget() {
	if (!mPushActive)
	    return;
	// clear value??
	// no, not for now.
	mSetPropertyMethod = null;
	mPushActive = false;
	if (debug)
	    System.err.println("PropertySubscriberBean disconnect push target");
    }

    /** do plumbing to set source */
    private synchronized void connectSource() {
	if (mDataspace==null ||
	    mItemName==null || mItemClassName==null)
	    // not configured
	    return;
	// create a global item monitor for the requisite item
	// template and register with the dataspace.
	ItemData template = createItemTemplate();
	// not local
	try {
	    if (debug)
		System.err.println("PropertySubscriberBean add listener "+
				   "for item[name=\""+mItemName+"\",class="+
				   "\""+mItemClassName+"\"]...");
	    dsSession = 
		mDataspace.addDataspaceEventListener(template, false, this);
	} catch (DataspaceInactiveException e) {
	    System.err.println("PropertySubscriberBean unable to add "+
			       "DS listener: "+e);
	    e.printStackTrace(System.err);
	}
	mIsConnected = true;
	connectPushTarget();
    }	    
    /** do plumbing to set push target */
    private synchronized void connectPushTarget() {
	if (!mIsConnected || mPushTarget==null || mPushPropertyName==null)
	    // not configured
	    return;
	// get and cache Method for set<property>
	mSetPropertyMethod = null;
	// capitalise
	StringBuffer capPropertyNameBuf = new StringBuffer(mPushPropertyName);
	if (capPropertyNameBuf.length()>0) 
	    capPropertyNameBuf.setCharAt(0, Character.toUpperCase
					 (capPropertyNameBuf.charAt(0)));
	try {
	    // NB setter may have arbitrary single argument type,
	    // to which value must be coerced when setting.
	    //   Look for set<Prop> method(s) with single argument
	    // and pull out class...
	    mSetPropertyMethod = null;
	    mPushPropertyClass = null;
	    Method [] methods = mPushTarget.getClass().getMethods();
	    int ci;
	    for (ci=0; ci<methods.length; ci++) {
		if (methods[ci].getName().equals("set"+capPropertyNameBuf)) {
		    Class [] args = methods[ci].getParameterTypes();
		    if (args.length!=1)
			continue;
		    mPushPropertyClass = args[0];
		    mSetPropertyMethod = methods[ci];
		    if (debug) 
			System.err.println("PropertySubscriberBean push "+
					   "target method set"+
					   capPropertyNameBuf+" has arg type "+
					   mPushPropertyClass.getName());
		    break;
		}
	    }
	} catch (Exception e) {
	    System.err.println("Warning: unable to get "+
			       "set"+capPropertyNameBuf+" Method from source");
	    return;
	}
	if (mSetPropertyMethod==null) {
	    System.err.println("Warning: unable to get "+
			       "set"+capPropertyNameBuf+" Method from source");
	    return;
	}	    
	if (debug)
	    System.err.println("PropertySubscriberBean connect push target");
	mPushActive = true;
	// initial value
	if (mValue!=null) {
	    setPushTargetValue();
	}	    
    }
    /** create item template */
    protected ItemData createItemTemplate() {
	ItemData item = new TupleImpl(new StringBoxImpl(mItemClassName),
				      null);
	item.name = mItemName;
	return item;
    }
    /** notify of event (cf DataCallbackPost) */
    public void dataspaceEvent(DataspaceEvent event) {
	if (event.event instanceof equip.data.AddEvent) {
	    AddEvent add = (AddEvent)event.event;
	    // make new item
	    synchronized (this) {
		mItemIds.insertElementAt(add.binding.item.id, 0);
		mCurrentItemId = add.binding.item.id;
		if (debug)
		    System.err.println("PropertySubscriberBean: new item "+
				       "found: "+mCurrentItemId);
	    }
	    // update value 
	    setValueFromTuple(add.binding.item);
	} else if (event.event instanceof equip.data.UpdateEvent) {
	    UpdateEvent upd = (UpdateEvent)event.event;
	    // if current then update value
	    boolean updateFlag = false;
	    synchronized(this) {
		if (mCurrentItemId!=null &&
		    mCurrentItemId.equals(upd.item.id))
		    updateFlag = true;
	    }
	    if (updateFlag)
		setValueFromTuple(upd.item);
	} else if (event.event instanceof equip.data.DeleteEvent) {
	    DeleteEvent del = (DeleteEvent)event.event;
	    // remove from list
	    synchronized(this) {
		int i;
		boolean doneFlag = false;
		for (i=0; i<mItemIds.size(); i++) {
		    GUID id = (GUID)mItemIds.elementAt(i);
		    if (id.equals(del.id)) {
			mItemIds.removeElementAt(i);
			doneFlag = true;
			break;
		    }
		}
		if (!doneFlag)
		    System.err.println("ERROR: PropertySubscriberBean got "+
				       "delete for unknown item "+del.id);
		// if current then update to next in list
		if (mCurrentItemId.equals(del.id)) {
		    if (mItemIds.size()==0) {
			if (debug) 
			    System.err.println("PropertySubscriberBean sees "+
					       "delete of only matching item");
			mValue = null;
			mCurrentItemId = null;
		    } else {
			if (debug) 
			    System.err.println("PropertySubscriberBean sees "+
					       "delete of current item and "+
					       "moves to old item");
			mCurrentItemId = (GUID)mItemIds.elementAt(0);
			mValue = null;
			ItemData item = null;
			try {
			    item = mDataspace.getItem(mCurrentItemId);
			} catch (DataspaceInactiveException e) {
			    System.err.println("PropertySubscriberBean unable "+
					       "to get next item value: "+e);
			    e.printStackTrace(System.err);
			}
			setValueFromTuple(item);
		    } 
		} else {
		    if (debug) 
			System.err.println("PropertySubscriberBean sees "+
					   "delete of non-current item");
		}
	    }
	}
    }
    /** set value from tuple */
    private void setValueFromTuple(ItemData item) {
	if (!(item instanceof Tuple)) {
	    System.err.println("ERROR: PropertySubscriberBean expected a "+
			       "Tuple, got a "+item.getClass().getName());
	    return;
	}
	Tuple tuple = (Tuple)item;
	if (tuple.fields==null || tuple.fields.length<2) {
	    System.err.println("ERROR: PropertySubscriberBean expected a "+
			       "2 (or more)-field Tuple");
	    return;
	}	    
	ValueBase field = tuple.fields[1];
	java.lang.Object value = null;
	if (field instanceof SerializedObjectImpl) {
	    SerializedObjectImpl ser = (SerializedObjectImpl)field;
	    try {
		value = ser.getValue();
	    } catch(Exception e) {
		System.err.println("ERROR: PropertySubscriberBean extracting "+
				   "serialized object: "+e);
		e.printStackTrace(System.err);
		return;
	    }
	} else {
	    // more decoding?? e.g. based on push property class?
	    // ....
	    value = field;
	}

	setValue(value);
    }
    /** value proxy */
    public java.lang.Object getValue() {
	return mValue;
    }
    /** value setter */
    private void setValue(java.lang.Object value) {
	java.lang.Object oldValue = mValue;
	synchronized (this) {
	    mValue = value;
	    if (mPushActive) 
		setPushTargetValue();
	}
	firePropertyChange("value", oldValue, value);
    }
    /** forward value to push target */
    private synchronized void setPushTargetValue() {
	try {
	    // Check that push property can be coerced to target class??
	    // (possibly more decoding?)
	    // ....
	    mSetPropertyMethod.invoke
		(mPushTarget,new java.lang.Object[] { mValue });
	} catch (Exception e) {
	    System.err.println("ERROR: PropertySubscriberBean (set "+
			       "value on push target): "+e);
	    e.printStackTrace(System.err);
	}
    }
}
/* EOF */
