/*
<COPYRIGHT>

Copyright (c) 2002-2005, University of Nottingham
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 - Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 - Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 - Neither the name of the University of Nottingham
   nor the names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</COPYRIGHT>

Created by: Chris Greenhalgh (University of Nottingham)
Contributors:
  Chris Greenhalgh (University of Nottingham)
  Ian MacColl (University of Glasgow)

*/
/* DiscoveryClientAgent 
 * initially autogenerated from ../../include/equip_discovery_types.idl
 * by eqidl
 * 
 * Chris Greenhalgh, 5/12/2002
 */


package equip.discovery;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.MulticastSocket;
import java.util.Vector;

public class DiscoveryClientAgentImpl extends DiscoveryClientAgent
{
	static boolean debug = false;

	/**
	 * started?
	 */
	boolean started = false;
	/**
	 * callback
	 */
	DiscoveryEventListener listener;
	/**
	 * discovery URLs to use
	 */
	String[] discoveryUrls;
	/**
	 * service types
	 */
	String[] serviceTypes;
	/**
	 * groups
	 */
	String[] groups;

	/**
	 * heard info
	 */
	static class HeardInfo
	{
		/**
		 * url
		 */
		String url;
		/**
		 * last heard time
		 */
		long lastHeardTime;
		/**
		 * announcement interval
		 */
		long announcementInterval;
		/**
		 * expire time
		 */
		long expireTime;

		/**
		 * constructor
		 */
		HeardInfo(String url,
		          long lastHeardTime, long announcementInterval)
		{
			this.url = url;
			setLastHeardTime(lastHeardTime, announcementInterval);
		}

		void setLastHeardTime(long time, long announcementInterval)
		{
			lastHeardTime = time;
			this.announcementInterval = announcementInterval;
			if (announcementInterval > 0)
			{
				expireTime = time + (announcementInterval *
						ANNOUNCEMENT_EXPIRE_COUNT.value) + 1000;
			}
			else
			{
				expireTime = 0;
			}
		}
	}

	/**
	 * all heard, in decreasing last heard order
	 */
	Vector heard = new Vector();

	/**
	 * expire thread
	 */
	ExpireThread expireThread;

	/**
	 * expire thread class
	 */
	class ExpireThread extends Thread
	{
		DiscoveryClientAgent lock;
		boolean stopFlag = false;

		ExpireThread(DiscoveryClientAgent lock)
		{
			this.lock = lock;
			this.start();
		}

		public void mystop()
		{
			stopFlag = true;
			this.interrupt();
		}

		public void run()
		{
			while (!stopFlag)
			{
				long now = System.currentTimeMillis();
				long nextExpireTime = 0;
				synchronized (lock)
				{
					int i;
					for (i = 0; i < heard.size(); i++)
					{
						HeardInfo h = (HeardInfo) heard.elementAt(i);
						if (h.expireTime == 0)
						// do not expire local entries or count for timer
						{
							continue;
						}
						if (now >= h.expireTime)
						{
							// expire
							if (debug)
							{
								System.err.println("Expire url " +
										h.url);
							}
							heard.removeElementAt(i);
							i--;
							if (listener != null)
							{
								listener.discoveryRemoveEvent(lock,
										h.url);
							}
						}
						else if (nextExpireTime == 0 ||
								h.expireTime < nextExpireTime)
						{
							nextExpireTime = h.expireTime;
						}
					}
				}
				synchronized (this)
				{
					try
					{
						if (nextExpireTime != 0)
						{
							wait(nextExpireTime - now);
						}
						else
						{
							wait();
						}
					}
					catch (Exception e)
					{
					}
				}
			}
		}
	}

	/**
	 * internal discovery client (sender) class
	 */
	class DiscoveryClient implements Runnable
	{
		/**
		 * socket to send discoverys on - just multicast to set TTL
		 */
		DatagramSocket sendSocket;
		/**
		 * send interval
		 */
		long resendInterval;
		/**
		 * send count
		 */
		long resendCount;
		/**
		 * next send time
		 */
		long nextSendTime;
		/**
		 * thread
		 */
		Thread myThread;
		/**
		 * destination address
		 */
		InetAddress destAddress;
		/**
		 * dest port
		 */
		int destPort;

		/**
		 * main constructor
		 */
		DiscoveryClient(InetAddress destAddress, int destPort)
		{
			this.destAddress = destAddress;
			this.destPort = destPort;
			try
			{
				if (destAddress.isMulticastAddress())
				{
					sendSocket = MulticastUtils.newMulticastSocket();
					try
					{
						java.lang.reflect.Method m = sendSocket.getClass().getMethod
								("setTimeToLive",
										new Class[]{Integer.TYPE});
						m.invoke(sendSocket,
								new java.lang.Object[]
										{new Integer(DISCOVERY_TTL.value)});
					}
					catch (Exception e)
					{
						System.err.println("sendSocket.setTimeToLive failed: " + e);
					}
				}
				else
				{
					// unicast
					sendSocket = new DatagramSocket();
					// also for use in receiving...
					unicastServer = new AnnouncementServer(sendSocket);
				}
			}
			catch (Exception e)
			{
				System.err.println("ERROR: in DiscoveryServerAgent." +
						"DiscoveryClient: " + e);
				e.printStackTrace(System.err);
				return;
			}
			if (destAddress.isMulticastAddress())
			{
				resendInterval = DISCOVERY_INTERVAL_S.value * 1000;
				resendCount = DISCOVERY_ATTEMPTS.value;
			}
			else
			{
				// if unicast, we need to keep-alive like a server
				resendInterval = ANNOUNCEMENT_INTERVAL_S.value * 1000;
				resendCount = -1; // magic value
			}
			long now = System.currentTimeMillis();
			nextSendTime = now;
			if (resendCount != 0)
			{
				myThread = new Thread(this);
				myThread.start();
			}
		}

		/**
		 * unicast announcement server
		 */
		protected AnnouncementServer unicastServer;

		/**
		 * stop
		 */
		synchronized void stop()
		{
			if (myThread != null)
			{
				//myThread.stop();
				Thread t = myThread;
				myThread = null;
				t.interrupt();
			}
			if (unicastServer != null)
			{
				unicastServer.stop();
			}
		}

		/**
		 * work...
		 */
		public void run()
		{
			System.err.println("DiscoveryClient running for " +
					destAddress + ":" + destPort + "...");
			while (resendCount != 0 && myThread != null)
			{
				// wait until next send
				long now = System.currentTimeMillis();
				if (now < nextSendTime)
				{
					try
					{
						Thread.sleep(nextSendTime - now);
					}
					catch (Exception e)
					{
					}
					continue;
				}
				// send!
				byte[] data = makeRequest();
				DatagramPacket p = new DatagramPacket(data,
						data.length,
						destAddress,
						destPort);
				try
				{
					if (debug)
					{
						System.err.println("Note: DiscoveryClient sends " +
								"to " + destAddress + ":" + destPort);
					}
					sendSocket.send(p);
				}
				catch (Exception e)
				{
					System.err.println("Warning: DiscoveryClient: " + e);
					e.printStackTrace(System.err);
				}
				// fix next send time
				nextSendTime += resendInterval;
				if (resendCount > 0)
				{
					resendCount--;
				}
			}
			if (debug)
			{
				System.err.println("DiscoveryClient completed all sends");
			}
		}
	}

	/**
	 * current discovery clients, 1 per url
	 */
	DiscoveryClient[] discoveryClients;

	/**
	 * internal announcement server (receiver/responder) class.
	 * Note: uses announcementDatas and servers from containing class.
	 */
	class AnnouncementServer implements Runnable
	{
		/**
		 * mc group
		 */
		InetAddress discAddress;
		/**
		 * mc port
		 */
		int discPort;
		/**
		 * multicast socket
		 */
		DatagramSocket discSocket;
		/**
		 * thread
		 */
		Thread myThread;

		/**
		 * main constructor
		 */
		AnnouncementServer(InetAddress discAddress,
		                   int discPort)
		{
			this.discAddress = discAddress;
			this.discPort = discPort;

			if (discAddress.isMulticastAddress())
			{
				try
				{
					MulticastSocket msocket = MulticastUtils.newMulticastSocket(discPort);
					discSocket = msocket;
					msocket.joinGroup(discAddress);
				}
				catch (Exception e)
				{
					System.err.println("ERROR: in AnnouncementServerAgent." +
							"AnnouncementServer: " + e);
					e.printStackTrace(System.err);
					return;
				}
			}
			else
			{
				// we should get started by the discovery client on their socket
				return;
			}
			myThread = new Thread(this);
			myThread.start();
		}

		/**
		 * unicast reflector constructor
		 */
		AnnouncementServer(DatagramSocket discSocket)
		{
			this.discSocket = discSocket;
			try
			{
				//discSocket = new DatagramSocket();
				discPort = discSocket.getLocalPort();
				discAddress = discSocket.getLocalAddress();
			}
			catch (Exception e)
			{
				System.err.println("ERROR: in AnnouncementServerAgent." +
						"AnnouncementServer: " + e);
				e.printStackTrace(System.err);
				return;
			}
			myThread = new Thread(this);
			myThread.start();
		}

		/**
		 * unicast callback constructor
		 */
		AnnouncementServer()
		{
			try
			{
				discSocket = new DatagramSocket();
				discPort = discSocket.getLocalPort();
				discAddress = discSocket.getLocalAddress();
			}
			catch (Exception e)
			{
				System.err.println("ERROR: in AnnouncementServerAgent." +
						"AnnouncementServer: " + e);
				e.printStackTrace(System.err);
				return;
			}
			myThread = new Thread(this);
			myThread.start();
		}

		int getPort()
		{
			return discPort;
		}

		InetAddress getAddress()
		{
			return discAddress;
		}

		/**
		 * stop
		 */
		synchronized void stop()
		{
			if (myThread != null)
			{
				//myThread.stop();
				Thread t = myThread;
				myThread = null;
				t.interrupt();
			}
		}

		/**
		 * work...
		 */
		public void run()
		{
			System.err.println("AnnouncementServer running on " +
					discAddress + ":" + discPort + "...");
			while (myThread != null)
			{
				byte announceData[] = new byte[1024];
				DatagramPacket announcepkt =
						new DatagramPacket(announceData,
								announceData.length);
				try
				{
					// get a packet
					discSocket.receive(announcepkt);
					if (myThread == null)
					// abort
					{
						break;
					}
				}
				catch (Exception e)
				{
					System.err.println("ERROR: in AnnouncementServer receive: " +
							e + " (give up!)");
					return;
				}
				// decode
				ServerAnnouncement announce = null;
				try
				{
					ByteArrayInputStream bins =
							new ByteArrayInputStream(announcepkt.getData(), 0,
									announcepkt.getLength());
					equip.runtime.ObjectInputStream oins =
							new equip.runtime.ObjectInputStream(bins);
					long version = oins.readInt();
					if (version != DISCOVERY_VERSION.value)
					{
						System.err.println
								("Warning: AnnouncementServer failed to " +
										"get a valid ServerAnnouncement object " +
										"from " + announcepkt.getAddress() + "/" +
										announcepkt.getPort() + " (" +
										announcepkt.getLength() + " bytes), " +
										"version " + version + " (expecting " +
										DISCOVERY_VERSION.value + ")");
						continue;
					}
					announce = (ServerAnnouncement) oins.readObject();
				}
				catch (Exception e)
				{
					System.err.println("Warning: AnnouncementServer failed to " +
							"get a valid ServerAnnouncement object " +
							"from " + announcepkt.getAddress() + "/" +
							announcepkt.getPort() + " (" +
							announcepkt.getLength() + " bytes)");
					continue;
				}
				processAnnouncement(announce);
			}
		}
	}

	/**
	 * current announcement servers, 1 per url
	 */
	AnnouncementServer[] announcementServers;
	AnnouncementServer unicastAnnouncementServer;

	/* lifecycle */
	public DiscoveryClientAgentImpl()
	{
		//....
	}

    /* API */

	/**
	 * initialiase.
	 * <p>
	 * May do sync calls to listener, e.g. if discovery URLs
	 * are actually server URLs.
	 */
	public synchronized void
	start(equip.discovery.DiscoveryEventListener listener,
	      String[] serviceTypes,
	      String[] groups,
	      String[] discoveryUrls)
	{
		if (started)
		{
			System.err.println("Warning: DiscoveryClientAgent.start " +
					"causes stop/start");
			stop();
		}
		this.listener = listener;
		this.serviceTypes = serviceTypes;
		this.groups = groups;
		this.discoveryUrls = discoveryUrls;

		int i;
		// announcements listeners, discovery senders
		if (discoveryUrls.length > 0)
		{
			// unicast
			unicastAnnouncementServer = new AnnouncementServer();
			announcementServers =
					new AnnouncementServer[discoveryUrls.length];
			discoveryClients =
					new DiscoveryClient[discoveryUrls.length];
			for (i = 0; i < discoveryUrls.length; i++)
			{
				// equipd url??
				int iColon = discoveryUrls[i].indexOf(':');
				if (iColon < 0 ||
						!(discoveryUrls[i].substring(0, iColon).
								equals("equipd")))
				{
					// no... pass straight to client
					announceUrl(discoveryUrls[i], 0);
					continue;
				}
				// it is a discovery url...
				try
				{
					InetAddress address;
					int port[] = new int[1];
					address = DiscoveryServerAgentImpl.parseUrl
							(discoveryUrls[i],
									DISCOVERY_GROUP.value,
									port);

					discoveryClients[i] =
							new DiscoveryClient(address, port[0]);

					// add 1 to port and address for announcement
					// rather than discovery IF MULTICAST ONLY
					byte[] addr = address.getAddress();
					if (address.isMulticastAddress())
					{
						port[0]++;
						addr[addr.length - 1]++;
						// address = InetAddress.getByAddress(addr);
						// assumes 4-byte address
						address = InetAddress.getByName(
								(addr[0] & 0xff) + "." +
										(addr[1] & 0xff) + "." +
										(addr[2] & 0xff) + "." +
										(addr[3] & 0xff)
						);
					}
					// make it
					announcementServers[i] =
							new AnnouncementServer(address, port[0]);
				}
				catch (Exception e)
				{
					System.err.println
							("ERROR: handling discovery url " +
									discoveryUrls[i] + ": " + e);
					e.printStackTrace(System.err);
				}
			}
		}
		expireThread = new ExpireThread(this);

		started = true;
		return;
	}

	/**
	 * initialiase using default discovery and announcement Urls.
	 */
	public void startDefault(equip.discovery.DiscoveryEventListener listener, String[] serviceTypes, String[] groups)
	{
		String[] discoveryUrls =
				DiscoveryServerAgentImpl.getDefaultDiscoveryUrls();
		start(listener, serviceTypes, groups, discoveryUrls);
		return;
	}

	/**
	 * terminate activity.
	 * <p>
	 * Will NOT generate removal callbacks.
	 */
	public void stop()
	{
		if (!started)
		{
			System.err.println("ERROR: DiscoveryClientAgent.stop called " +
					"when not started");
			return;
		}
		int i;
		if (announcementServers != null)
		{
			for (i = 0; i < announcementServers.length; i++)
			{
				if (announcementServers[i] != null)
				{
					announcementServers[i].stop();
				}
			}
			announcementServers = null;
		}
		if (discoveryClients != null)
		{
			for (i = 0; i < discoveryClients.length; i++)
			{
				if (discoveryClients[i] != null)
				{
					discoveryClients[i].stop();
				}
			}
			discoveryClients = null;
		}
		unicastAnnouncementServer.stop();
		unicastAnnouncementServer = null;
		expireThread.mystop();
		expireThread = null;
		// remove rather than unannounce
		synchronized (this)
		{
			while (heard.size() > 0)
			{
				HeardInfo h = (HeardInfo) heard.elementAt(0);
				heard.removeElementAt(0);
				//if (listener!=null)
				//listener.discoveryRemoveEvent(this, h.url);
			}
		}
		started = false;
		return;
	}

	/* subclasses....*/
	void processAnnouncement(ServerAnnouncement announce)
	{
		int si;
		for (si = 0; announce.infos != null && si < announce.infos.length; si++)
		{
			// match?
			if (DiscoveryServerAgentImpl.
					matchServiceTypes(serviceTypes,
							announce.infos[si].serviceTypes) &&
					DiscoveryServerAgentImpl.
							matchServiceTypes(groups,
									announce.infos[si].groups))
			{
				// so far so good
				int ui;
				for (ui = 0; announce.infos[si].urls != null &&
						ui < announce.infos[si].urls.length; ui++)
				{
					announceUrl(announce.infos[si].urls[ui],
							announce.announcementIntervalMillis);
				}
			}
		}
	}

	void announceUrl(String url, long announcementInterval)
	{
		synchronized (this)
		{
			if (debug)
			{
				System.err.println("DiscoveryClientAgent: announce " + url + "...");
			}
			int i;
			long now = System.currentTimeMillis();
			for (i = 0; i < heard.size(); i++)
			{
				HeardInfo h = (HeardInfo) heard.elementAt(i);
				if (h.url.equals(url))
				{
					if (debug)
					{
						System.err.println("- already present; update heard time");
					}
					h.setLastHeardTime(now, announcementInterval);
					return;
				}
			}
			// not heard before
			HeardInfo h = new HeardInfo(url, now, announcementInterval);
			heard.addElement(h);

			// kick expire thread
			synchronized (expireThread)
			{
				expireThread.notify();
			}

			// callback - note locked - be careful
			if (listener != null)
			{
				listener.discoveryEvent(this, url);
			}
		}
	}

	/**
	 * max # heard records in request - size limit
	 */
	static final int MAX_HEARD_COUNT = 20;

	/**
	 * make request
	 */
	byte[] makeRequest()
	{
		try
		{
			ByteArrayOutputStream bouts = new ByteArrayOutputStream();
			equip.runtime.ObjectOutputStream oouts =
					new equip.runtime.ObjectOutputStream(bouts);
			oouts.writeInt(DISCOVERY_VERSION.value);

			DiscoveryRequest request = new DiscoveryRequestImpl();
			request.port = (short) unicastAnnouncementServer.getPort();
			request.serviceTypes = serviceTypes;
			request.groups = groups;
			// what have we heard already?
			synchronized (this)
			{
				int nheard = heard.size();
				if (nheard > MAX_HEARD_COUNT)
				{
					nheard = MAX_HEARD_COUNT;
				}
				int i;
				// end of list = heard more recently - suppressed
				request.heard = new String[nheard];
				for (i = 0; i < nheard; i++)
				{
					request.heard[i] = ((HeardInfo) heard.elementAt
							(heard.size() - 1 - i)).url;
				}
			}
			oouts.writeObject(request);
			oouts.flush();
			byte[] data = bouts.toByteArray();
			return data;
		}
		catch (Exception e)
		{
			System.err.println("ERROR: DiscoveryClientAgent making " +
					"request: " + e);
			e.printStackTrace(System.err);
		}
		return null;
	}

	/**
	 * get currently known server URLs
	 */
	public synchronized String[] getKnownServers()
	{
		String[] known = new String[heard.size()];
		int i;
		for (i = 0; i < heard.size(); i++)
		{
			known[i] = ((HeardInfo) heard.elementAt
					(heard.size() - 1 - i)).url;
		}
		return known;
	}
}